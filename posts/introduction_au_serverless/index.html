<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Introduction au serverless ::
        Klanik tech blog — Tech blog
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="Je tiens à préciser que dans cet article je parle de déploiement d’applications Web et de scripts d’automatisation, pas d’applications client lourdes.
Le serverless Le serverless est une méthode permettant de déployer des morceaux d’application sans se soucier de l’infrastructure technique porteuse. Dans un déploiement classique (on parle là bien de legacy mais également de déploiements type Docker EE / Kubernetes), notre application est bundlée et doit être déployée sur un ou plusieurs serveurs."
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/introduction_au_serverless/" />





<link rel="stylesheet" href="/assets/style.css" />

<link rel="stylesheet" href="/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="/img/favicon.png" />


<link href="/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Introduction au serverless"/>
<meta name="twitter:description" content="Je tiens à préciser que dans cet article je parle de déploiement d’applications Web et de scripts d’automatisation, pas d’applications client lourdes.
Le serverless Le serverless est une méthode permettant de déployer des morceaux d’application sans se soucier de l’infrastructure technique porteuse. Dans un déploiement classique (on parle là bien de legacy mais également de déploiements type Docker EE / Kubernetes), notre application est bundlée et doit être déployée sur un ou plusieurs serveurs."/>



<meta property="og:title" content="Introduction au serverless" />
<meta property="og:description" content="Je tiens à préciser que dans cet article je parle de déploiement d’applications Web et de scripts d’automatisation, pas d’applications client lourdes.
Le serverless Le serverless est une méthode permettant de déployer des morceaux d’application sans se soucier de l’infrastructure technique porteuse. Dans un déploiement classique (on parle là bien de legacy mais également de déploiements type Docker EE / Kubernetes), notre application est bundlée et doit être déployée sur un ou plusieurs serveurs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/introduction_au_serverless/" />
<meta property="article:published_time" content="2020-10-13T17:52:51+02:00" />
<meta property="article:modified_time" content="2020-10-13T17:52:51+02:00" /><meta property="og:site_name" content="Klanik tech blog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Klanik tech blog</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://www.klanik.com">Klanik.com</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://www.klanik.com">Klanik.com</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Introduction au serverless</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-10-13
        </span>

        
          
        
      

      


      
        <span class="post-read-time"
          >— 5 min read</span
        >
      
    </div>

    

    

    <div class="post-content">
      
        <h2>Table of Contents</h2>
        <aside class="table-of-contents"><nav id="TableOfContents"></nav></aside>
      
      <p>Je tiens à préciser que dans cet article je parle de déploiement d’applications Web et de scripts d’automatisation, pas d’applications client lourdes.</p>
<h1 id="le-serverless">Le serverless</h1>
<p>Le serverless est une méthode permettant de déployer des morceaux d’application sans se soucier de l’infrastructure technique porteuse. Dans un déploiement classique (on parle là bien de legacy mais également de déploiements type Docker EE / Kubernetes), notre application est bundlée et doit être déployée sur un ou plusieurs serveurs. Ce processus peut être automatisé et la couche d’infrastructure un peu abstraite (coucou Kubernetes), mais le principe reste le même.</p>
<p>Dans une architecture serverless, l’application est « cassée » en modules, puis en fonctions, un peu comme dans un développement normal, mais encore plus. En effet, il va s’agir de déployer chaque fonction de notre programme individuellement.</p>
<h1 id="le-fonctionnement-du-serverless-est-simple">Le fonctionnement du serverless est simple</h1>
<p>Une fonction (et ses ressources et dépendances) réside sur un serveur d’exécution
Un événement vient trigger la dite fonction
Cette dernière s’exécute et éventuellement (mais pas forcément) produit un résultat
Le résultat produit est retourné au déclencheur de l’évènement
Cela peut paraître une idée saugrenue, mais une infrastructure serverless apporte énormément d’avantages stratégiques pour le développement et la maintenabilité d’une application :</p>
<p>Chaque fonction peut être écrite dans un langage propre, ce qui est un des gros points du serverless. Un projet aux multiples facettes, porteur de backend Javascript, de scripts d’automatisation Java, de scripts de maintenance Shell et d’outils de statistiques Python peut voir toutes ses fonctions réunies dans un seul projet.
Chaque fonction peut être trigger par un ou plusieurs types d’événements, permettant de définir une fonction comme appelable par, par exemple, un appel http sur une URL définie, mais également un événement système, un appel RPC, et même, avec des intégrations plus poussées, un message Slack ou Discord, un événement de base de données, etc.
Chaque fonction réside dans son propre environnement d’exécution, ce qui permet d’exécuter la même fonction dans plusieurs environnements, mais également de gérer la scalabilité de chaque fonction indépendamment, ce qui veut dire que si une fonction n’est pas utilisée, elle est tout simplement désinstanciée du serveur d’exécution (ce qui peut causer le problème du Cold Start, expliqué plus bas, mais fait qu’une fonction inutilisée ne vous coûte rien).
En clair, votre équipe n’a plus besoin d’un cluster entier de machines pour déployer son projet, mais juste d’un provider serverless (comme AWS avec lambda), qui facturera simplement à l’utilisation.
Votre équipe de développement n’a plus besoin de se soucier d’infrastructure, ce qui est un avantage considérable dans beaucoup de petites structures, mais également dans des grosses structures où les développeurs sont recrutés pour… eh bien développer (ce point a tendance à être négligé, croyez-moi).
Le Time To Market est considérablement réduit, car lorsqu’une fonctionnalité est développée est testée, vous avez juste besoin de redéployer la ou les fonctions impactée(s), ce qui se fait généralement en une à deux commandes. La nouvelle version de la fonction est ensuite accessible à la place de l’ancienne, pour tous les triggers définis, pour tout le monde. Facile non ?
Alors avec ça, pourquoi continuer à faire des applications classiques ? Eh bien le serverless, c’est bien, mais comme tout ce qui est bien et novateur, il vient également avec son lot de problématiques :</p>
<p>Il est plus compliqué de débugger et tester son application. Il est vrai que l’environnement de production est plus compliqué à reproduire pour le développement qu’avec admettons une image Docker ou un environnement JVM défini. Le fait que l’application soit cassée en plein de petites fonctions peut également être intimidant, mais c’est également un moyen de bien séparer les différentes logiques, donc chacun son avis.
Les traitements longs n’ont pas leur place en serverless, de par son architecture, faite pour des processus courts qui se contentent de répondre rapidement à un événement. Les processus longs (quelques secondes à quelques minutes) coûteront cher (car facturés au temps d’exécution) et pire, risqueront de se voir interrompus avant la fin.
La portabilité n’est pas toujours assurée, car le serverless ne se repose pas (pas souvent) sur une infrastructure maîtrisée par l’entreprise. Des outils pour réaliser différentes fonctions sont alors mises à disposition par le provider, et ces fonctions lui sont propres, ce qui rend notre compte dépendant du provider.
Les performances de l’application peuvent être affectées, car, on le rappelle, chaque fonction tourne dans son propre environnement d’exécution, son propre « conteneur » pour faire un parallèle avec Docker ou k8s, et si une fonction n’est pas du tout utilisée, le provider va la scaller à 0 instances. C’est à la fois le plus gros avantage du serverless (car une fonction non utilisée ne coûte rien), mais son plus gros inconvénient, car si une fonction scallée à 0 est appelée, il lui faut le temps de démarrer. Ce temps est généralement court (quelques secondes tout au plus), mais il faut savoir qu’il existe.
Pour information, ceci s’appelle sobrement le Cold Start.</p>
<p>Soyons clair, aucune de ces problématiques n’est insurmontable. Des moyens existent pour les contourner, et le jeu en vaut la chandelle.</p>
<p>Les outils du serverless
Si le serverless vous intéresse, voici quelques outils, ressources et providers sur lesquelles vous devriez vous pencher :</p>
<p>com, framework serverless permettant d’accélérer le développement et d’émuler un environnement serverless (par exemple AWS, Azure, Google, Kubeless, etc.). Ils ont également un blog très complet et très actif qui parle de l’actualité du serverless
Knative et Kubeless, deux outils permettant d’ajouter un aspect serverless à un cluster Kubernetes (vous connaissez mon amour pour k8s, j’ai testé les deux, je conseille les deux)
Apache Openwhisk, un provider serverless opensource (à installer sur sa propre infrastructure)
AWS Lambda, car après tout, actuellement, AWS, reste le provider préféré des entreprises qui se lancent dans l’aventure serverless</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
              <span class="button previous">
                <a href="/posts/apm_cicd/">
                  <span class="button__icon">←</span>
                  <span class="button__text">APM en mode avec CI/CD avec sitespeed.io</span>
                </a>
              </span>
            
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Klanik tech blog</span
    >
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span
          >© 2020 Powered by
          <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span
        >
        <span
          >Theme created by
          <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span
        >
      </div>
    
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
